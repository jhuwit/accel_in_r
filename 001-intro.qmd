---
title: "Introduction to Accelerometer Data"
author: "John Muschelli and Lily Koffman"
format: 
  revealjs:
    theme: default
    smaller: true
    slide-number: true
    transition: fade
    progress: true
    center: false
    width: 1200
    height: 700
    background: background.png
    logo: images/jhu.png
bibliography: references.bib
---

```{r setup, include = FALSE}
library(knitr)
library(hms)
library(lubridate)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

## Introduction to Accelerometer Data

### Learning Objectives

- Understand the basics of procewssing accelerometer data
- GT3X -> CSV/Activity Counts/Steps
- Open source methods in R
- Many of the methods either have a Python analog
- Lots are R wrapper for Python libraries
- GGIR

::: {.notes}
Speaker notes go here.
:::

---

## What is Accelerometer Data?

- **Sensor that measures acceleration** in 3D space: X/Y/Z
- X-axis: Left-Right
- Y-axis: Up-Down
- Z-axis: Forward-Backward
- Typically measured in **g-forces (g)** or **m/sÂ²**
- Sampled at regular time intervals (e.g., 30Hz, 100Hz)

```plaintext
Timestamp                  X        Y        Z
2025-02-17 12:00:00.0125   0.02     0.98     0.03
2025-02-17 12:00:00.0250   0.04     0.95     0.05
2025-02-17 12:00:00.0375  -0.01     0.99     0.02
```


---

## How Does It Work?

1. Small **MEMS accelerometer** inside a wearable device
2. Measures acceleration by detecting **motion and gravitational forces**
3. Outputs time-series data: raw acceleration signals


---

## Wrist-Worn vs. Hip-Worn Accelerometers

| Feature       | Wrist-Worn Devices  | Hip-Worn Devices  |
|--------------|------------------|-----------------|
| Placement    | Worn on wrist    | Attached to belt |
| Compliance   | Higher           | Lower           |
| Activity Types | Captures arm movements | Better for whole-body movement |

---

## Common Data Formats

- **Raw Accelerometer Data** (high-resolution time-series data)
- **Activity Counts** (aggregated over time windows)
- **Wear Time Detection** (non-wear vs. wear periods)
- **Steps** (estimation of a "step")

---

## Example Studies

- **NHANES Accelerometry (CDC)**
- Large-scale population studies using wrist-worn devices
- Released raw data - we released processed version
- **UK Biobank Wearable Data**
- Over 100,000 participants with 7-day wrist accelerometer recordings

---

## Technical Stuff: Conda/Environments

- If using Python, you know conda
- If using R, Python link using `reticulate` package
- Multiple conda environments may be needed
- package/module A needs numpy <= 2.11 and package B needs numpy 2.30
- "Switching" conda environments **within** a script/session is a hassle

## Brief Package overview


:::: {.columns}

::: {.column width="50%"}

- `read.gt3x` - reads GT3X format [CRAN]()/[GitHub]()
- `agcounts` - on CRAN, wrapper of Python and other uses [CRAN]()/[GitHub]()
- `actilifecounts` - on CRAN, implements Activity Counts native in R [CRAN]()/[GitHub]()
- `agcounter`: direct wrapper of Python code (uses conda), but not on CRAN [CRAN]()/[GitHub]()
- `GGIR` - the firehose of outputs/`GGIRread` - reader [CRAN]()/[GitHub]()
- `actigraph.sleepr` - implements Choi/Troiano wear time methods [CRAN]()/[GitHub]()

:::

::: {.column width="50%"}

- `stepcount` - implements stepcount algorithm from Oxford group [CRAN]()/[GitHub]()
- `walking` - implements other walking/step estimation methods
- `ADEPT` - walking segmentation
- `MIMSunit` - calculates MIMS units
- `acc` - explore accelerometer data
- `accelerometry` - functions for Processing Accelerometer Data 
- `SummarizedActigraphy` - dumping ground for some functions we made


:::

::::

## Data

- Single file `AI15_MOS2D09170398_2017-10-30.gt3x` from [Figshare repository](https://springernature.figshare.com/collections/Upper_limb_activity_of_twenty_myoelectric_prosthesis_users_and_twenty_healthy_anatomically_intact_adults_/4457855) 
- From @upper_limb_figshare, which was released with the publication @chadwell2019upper. 
- Start with GT3X file - ActiGraph format
- We can talk technical aspects of this binary file, but let's just read it in


## Getting Data

```{r download_file, echo = TRUE}
gt3x_file = here::here("data/AI15_MOS2D09170398_2017-10-30.gt3x")
if (!file.exists(gt3x_file)) {
  url = paste0("https://github.com/jhuwit/", 
               "accel_in_r", 
               "/raw/main/",
               "data/AI15_MOS2D09170398_2017-10-30.gt3x")
  curl::curl_download(url = url, destfile = gt3x_file)
}
```

## Read in the data

- `asDataFrame` - make it a `data.frame`
- `imputeZeroes` - discuss idle sleep mode

```{r read_file}
library(read.gt3x)
(df = read.gt3x::read.gt3x(path = gt3x_file, 
                           asDataFrame = TRUE, 
                           imputeZeroes = TRUE))
```

::: {.notes}
Idle sleep mode is a battery saving option when enabling and setting up ActiGraph devices.  It's a hassle, don't use it unless you have to.  It causes "gaps" in the GT3X file that are truly missing , but this is an issue with many processing methods (gaps), so you can "impute" zeroes into the data set, which aren't correct either. 
:::

## Where are the subseconds?

`digits.secs` - show a certain number of digits for seconds from time

:::: {.columns}

::: {.column width="50%"}

```{r options}
getOption("digits.secs")
options(digits.secs = 3)
df
```

::: 

::: {.column width="50%"}

```{r digits_secs_tbl}
options(digits.secs = 3)
as_tibble(df)
```

::: 

:::: 



## Time (data) is not your friend

- Time zones are hell

```{r tz}
lubridate::tz(df$time)
```

- `read.gt3x` attached a GMT timezone to the data, but there is a note

```{r gt3x_note, echo = FALSE}
knitr::include_graphics(here::here("images/read.gt3x_note.png"))
```

- "local" means local to the device/initialization, not your machine


## Header - in the attributes

The format of `df` is a `activity_df`, which is why you see the header information, but you need to know how to extract these:

:::: {.columns}

::: {.column width="50%"}

- `acceleration_max` useful for `MIMSunit`

```{r attributes_df}
names(attributes(df))
attr(df, "sample_rate")
attr(df, "acceleration_max")
attr(df, "time_zone")
```

:::

::: {.column width="50%"}

```{r show_attr_header}
attr(df, "header")
```
:::
::::

# Important - save attributes if converting to `data.frame`/`tibble`

## Zeroes

- Again, these zeroes are not "real" zeroes"

```{r zeroes}
library(dplyr)
df %>% filter(X == 0, Y == 0, Z == 0)
```

## Fill Zeros - using LOCF

:::: {.columns}

::: {.column width="50%"}

- Fill these in using last observation carried forward (LOCF)
- What ActiLife does
- Respects a zero variance for previous values

:::

::: {.column width="50%"}

```{r fill_data}
sample_rate = attr(df, "sample_rate")
acceleration_max = as.numeric(attr(df, "acceleration_max"))
df_zeros = df = dplyr::as_tibble(df)
df = df %>% 
  # find where all zeroes/imputed zeroes
  mutate(all_zero = X == 0 & Y == 0 & Z == 0) %>% 
  # replace all 0 with NA so it can be filled  
  mutate(
    X = ifelse(all_zero, NA_real_, X),
    Y = ifelse(all_zero, NA_real_, Y),
    Z = ifelse(all_zero, NA_real_, Z)
  )
df = df %>% 
  # last observation carried forward
  tidyr::fill(X, Y, Z, .direction = "down")
head(df %>% filter(all_zero | dplyr::lead(all_zero, default = FALSE)))
```

:::
::::

```{r remove, echo=FALSE}
df = df %>% 
  select(-all_zero)
```

# Visualization

# If you plot less with more data, something is going in the wrong direction <br>- Karl Broman

## Reshaping Raw Data for `ggplot2`

```{r reshape_data_for_plot_long}
long = df %>% 
  tidyr::pivot_longer(cols = c(X, Y, Z), 
                      names_to = "axis", 
                      values_to = "acceleration")
head(long)
```

Lots of data:

```{r reshape_data_for_plot_long_lot}
long %>% 
  count(axis)
```
## Plot First 5 minutes (30Hz dense)

```{r quickplot}
library(ggplot2); library(lubridate)
(qp = long %>% 
    filter(between(time, floor_date(time[1]), 
                   floor_date(time[1]) + as.period(5, "minutes"))) %>% 
    ggplot(aes(x = time, y = acceleration, colour = axis)) + 
    geom_rect(aes(xmin = ymd_hms("2017-10-30 15:00:22"),
                  xmax = ymd_hms("2017-10-30 15:00:37"),
                  ymin = -Inf,
                  ymax = Inf), fill = 'pink', alpha = 0.05) + 
    geom_line())
```


## Same Plot with Zeroes

```{r quickplot2, echo = FALSE}
(qp_zeros = df_zeros %>% 
   tidyr::pivot_longer(cols = c(X, Y, Z), 
                       names_to = "axis", 
                       values_to = "acceleration") %>% 
   filter(between(time, floor_date(time[1]), 
                  floor_date(time[1]) + as.period(5, "minutes"))) %>% 
   ggplot(aes(x = time, y = acceleration, colour = axis)) + 
   geom_rect(aes(xmin = ymd_hms("2017-10-30 15:00:22"),
                 xmax = ymd_hms("2017-10-30 15:00:37"),
                 ymin = -Inf,
                 ymax = Inf), fill = 'pink', alpha = 0.05) + 
   geom_line())
```

## Plot all data
- Creating separate `date` and `time` useful for plotting/summary

```{r long_create_hourtime, eval = FALSE}
(long = long %>% 
   mutate(date = as_date(time),
          hourtime = hms::as_hms(time)))
```
```{r long_create_hourtime_show, eval = TRUE, echo = FALSE}
(long = long %>% 
   head(10) %>% 
   mutate(date = as_date(time),
          hourtime = hms::as_hms(time)))
```


# Plot all data

:::: {.columns}

::: {.column width="50%"}
- Creating separate `date` and `time` useful for plotting/summary
- Has to plot `r nrow(long)` points (takes a long time)

```{r run_bigplot, eval = FALSE}
long %>% 
  ggplot(aes(x = hourtime, y = acceleration, colour = axis)) + 
  facet_wrap(~ date, ncol = 1) + 
  geom_step()
```
:::



::: {.column width="50%"}
```{r show_bigplot}
#| out-height: "100%"
knitr::include_graphics(here::here("docs/images/bigplot.png"))
```

:::
::::


# References
